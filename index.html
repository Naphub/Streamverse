<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamVerse - Movies & TV Shows</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script type='text/javascript' src='//candyaversion.com/98/78/12/9878125c00c51d2fe29f4bb8c227f1fc.js'></script>
    <!-- Configure Tailwind to use Inter font and a dark theme -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#111827', // Dark Slate
                        'secondary-dark': '#1f2937', // Slightly lighter slate for cards/backgrounds
                        'accent': '#ef4444', // Red for primary highlights (like a streaming service)
                        'text-light': '#f3f4f6',
                        'text-muted': '#9ca3af',
                        'filter-active': '#22c55e', // Emerald green for active filters
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar for a cleaner look on dark mode */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }

        .poster-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }
        .poster-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        
        .sort-button, .filter-button {
            padding: 8px 16px;
            border-radius: 9999px; /* full rounded */
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .sort-button.active {
            background-color: var(--tw-colors-accent); /* Red accent color */
            color: var(--tw-colors-text-light);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .filter-button.active {
            background-color: var(--tw-colors-filter-active); /* Green filter color */
            color: var(--tw-colors-primary-dark);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .sort-button:not(.active), .filter-button:not(.active) {
            background-color: var(--tw-colors-gray-700);
            color: var(--tw-colors-text-muted);
        }
        .sort-button:not(.active):hover, .filter-button:not(.active):hover {
            background-color: var(--tw-colors-gray-600);
            color: var(--tw-colors-text-light);
        }

        /* Styling for the mobile bottom nav active state */
        .mobile-nav-item.active {
            color: var(--tw-colors-accent);
        }
        
        /* Ensure sort rows still scroll horizontally if too many buttons */
        .sort-scroll-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 8px; /* For scrollbar visibility */
        }
        .sort-scroll-container .sort-button {
            flex-shrink: 0;
        }
        
        /* New styles for stream source switcher buttons */
        .stream-source-button {
            font-weight: 500;
            white-space: nowrap;
            padding: 6px 12px;
            border-radius: 0.5rem;
        }
        .active-source-button {
            outline: none;
            background-color: #ef4444; /* Red accent color */
            color: var(--tw-colors-text-light);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .inactive-source-button {
            background-color: var(--tw-colors-gray-700);
            color: var(--tw-colors-text-muted);
        }
        .inactive-source-button:hover {
            background-color: oklch(70.4% 0.191 22.216);
            color: var(--tw-colors-text-light);
        }
    </style>
</head>
<body class="bg-primary-dark text-text-light font-sans min-h-screen">

    <!-- Header & Navigation -->
    <header class="bg-secondary-dark sticky top-0 z-10 shadow-lg">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            
            <!-- Logo and Desktop Navigation Links -->
            <div class="flex items-center space-x-8">
                <h1 class="text-3xl font-bold text-accent">StreamVerse</h1>
                <!-- Desktop Navigation (Visible on sm and up) -->
                <nav id="desktop-nav" class="hidden sm:flex space-x-6 text-lg">
                    <a href="#" onclick="navigateTo('popular-movies-section', 1)" class="hover:text-accent transition duration-200 font-medium nav-link pb-1 border-b-2 border-transparent" data-section-id="popular-movies-section">Movies</a>
                    <a href="#" onclick="navigateTo('popular-tv-section', 1)" class="hover:text-accent transition duration-200 font-medium nav-link pb-1 border-b-2 border-transparent" data-section-id="popular-tv-section">TV Shows</a>
                    <!-- Removed Anime Navigation Link -->
                </nav>
            </div>

            <!-- Search Bar (Desktop View: lg:block) -->
            <div id="desktop-search-container" class="hidden lg:block w-1/3 relative">
                <input
                    type="text"
                    id="search-input-desktop"
                    placeholder="Search for movies, TV shows..."
                    class="w-full py-2 pl-4 pr-10 bg-gray-700 text-text-light rounded-full focus:ring-2 focus:ring-accent focus:outline-none placeholder-text-muted transition duration-200"
                    onkeydown="if(event.key === 'Enter') handleSearchDesktop()"
                >
                <button
                    onclick="handleSearchDesktop()"
                    class="absolute right-0 top-0 mt-2 mr-3 text-text-muted hover:text-accent transition duration-200"
                >
                    <!-- Search Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                </button>
            </div>
            
            <!-- Mobile Search Toggle Button (Visible on mobile, hidden on lg and up) -->
            <button id="mobile-search-toggle" class="sm:hidden text-text-light p-2 rounded-full hover:bg-gray-700 transition" onclick="toggleMobileSearchOverlay()">
                <!-- Search Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
            </button>
        </div>
    </header>
    
    <!-- Mobile Search Overlay (Toggled by JS) -->
    <div id="mobile-search-filter-overlay" class="lg:hidden absolute top-[76px] left-0 right-0 bg-secondary-dark z-30 p-4 border-b border-gray-700 transition-all duration-300 transform -translate-y-full opacity-0 pointer-events-none">
        <div class="relative">
            <input
                type="text"
                id="search-input-mobile"
                placeholder="Search for movies, TV shows..."
                class="w-full py-2 pl-4 pr-10 bg-gray-700 text-text-light rounded-full focus:ring-2 focus:ring-accent focus:outline-none placeholder-text-muted transition duration-200"
                onkeydown="if(event.key === 'Enter') handleSearchMobile()"
            >
            <button
                onclick="handleSearchMobile()"
                class="absolute right-0 top-0 mt-2 mr-3 text-text-muted hover:text-accent transition duration-200"
            >
                <!-- Search Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
            </button>
        </div>
    </div>


    <!-- Main Content Area (Added mobile bottom padding: pb-20) -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-8 pb-20 sm:pb-8">

        <!-- Status/Error Message Area (hidden by default) -->
        <div id="status-message" class="hidden bg-red-800 p-4 rounded-lg mb-6 text-center text-text-light"></div>

        <!-- Search Results Section (hidden by default) -->
        <section id="search-results-section" class="mb-12 hidden">
            <h2 class="text-3xl font-semibold mb-6 border-b-2 border-accent pb-2">Search Results</h2>
            <!-- Filter buttons are not relevant for search results as they are sorted by relevance -->
            <div id="search-results-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6">
                <!-- Search results will be injected here -->
            </div>
            <!-- Pagination Controls for Search -->
            <div id="search-results-pagination" class="mt-6 flex justify-center"></div>
        </section>

        <!-- Popular Movies Section -->
        <section id="popular-movies-section" class="mb-12">
            <h2 class="text-3xl font-semibold mb-4 border-b-2 border-accent pb-2">Movies</h2>
            
            <!-- Sort Filters for Movies (Still using horizontal scrolling row) -->
            <div class="mb-4">
                <label class="text-text-muted text-sm font-semibold block mb-2">Sort By:</label>
                <div id="movie-sort-filters" class="flex gap-2 sort-scroll-container">
                    <button class="sort-button active" data-type="movie" data-sort="popularity" onclick="changeSort('movie', 'popularity')">Popularity</button>
                    <button class="sort-button" data-type="movie" data-sort="release_date" onclick="changeSort('movie', 'release_date')">New Releases</button>
                </div>
            </div>

            <!-- Filter Dropdowns Row (Mobile: Flex Row) / Filter Buttons Row (Desktop: Block/Wrap) -->
            <div class="flex sm:block gap-4 mb-6">
                <!-- Genre Filter -->
                <div class="w-1/2 sm:w-full">
                    <label class="text-text-muted text-sm font-semibold block mb-2">Filter by Genre:</label>
                    
                    <!-- Mobile Dropdown -->
                    <select id="movie-genre-dropdown" class="sm:hidden w-full bg-secondary-dark text-text-light rounded-lg p-2.5 focus:ring-accent focus:border-accent border border-gray-700" onchange="changeGenre('movie', this.value)">
                        <!-- Options injected here -->
                    </select>

                    <!-- Desktop Buttons -->
                    <div id="movie-genre-filters" class="hidden sm:flex flex-wrap gap-2 mb-4 sm:mb-4">
                        <!-- Genre buttons injected here -->
                    </div>
                </div>

                <!-- Country Filter -->
                <div class="w-1/2 sm:w-full">
                    <label class="text-text-muted text-sm font-semibold block mb-2">Filter by Country:</label>
                    
                    <!-- Mobile Dropdown -->
                    <select id="movie-country-dropdown" class="sm:hidden w-full bg-secondary-dark text-text-light rounded-lg p-2.5 focus:ring-accent focus:border-accent border border-gray-700" onchange="changeCountry('movie', this.value)">
                        <!-- Options injected here -->
                    </select>
                    
                    <!-- Desktop Buttons -->
                    <div id="movie-country-filters" class="hidden sm:flex flex-wrap gap-2">
                        <!-- Country buttons injected here -->
                    </div>
                </div>
            </div>
            
            <div id="popular-movies-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6">
                <!-- Content will be injected here -->
            </div>
            <!-- Pagination Controls for Movies -->
            <div id="popular-movies-pagination" class="mt-6 flex justify-center"></div>
        </section>

        <!-- Popular TV Shows Section -->
        <section id="popular-tv-section" class="mb-12 hidden">
            <h2 class="text-3xl font-semibold mb-4 border-b-2 border-accent pb-2">TV Shows</h2>

            <!-- Sort Filters for TV Shows (Still using horizontal scrolling row) -->
            <div class="mb-4">
                <label class="text-text-muted text-sm font-semibold block mb-2">Sort By:</label>
                <div id="tv-sort-filters" class="flex gap-2 sort-scroll-container">
                    <button class="sort-button active" data-type="tv" data-sort="popularity" onclick="changeSort('tv', 'popularity')">Popularity</button>
                    <button class="sort-button" data-type="tv" data-sort="release_date" onclick="changeSort('tv', 'release_date')">New Releases</button>
                </div>
            </div>

            <!-- Filter Dropdowns Row (Mobile: Flex Row) / Filter Buttons Row (Desktop: Block/Wrap) -->
            <div class="flex sm:block gap-4 mb-6">
                <!-- Genre Filter -->
                <div class="w-1/2 sm:w-full">
                    <label class="text-text-muted text-sm font-semibold block mb-2">Filter by Genre:</label>
                    
                    <!-- Mobile Dropdown -->
                    <select id="tv-genre-dropdown" class="sm:hidden w-full bg-secondary-dark text-text-light rounded-lg p-2.5 focus:ring-accent focus:border-accent border border-gray-700" onchange="changeGenre('tv', this.value)">
                        <!-- Options injected here -->
                    </select>

                    <!-- Desktop Buttons -->
                    <div id="tv-genre-filters" class="hidden sm:flex flex-wrap gap-2 mb-4 sm:mb-4">
                        <!-- Genre buttons injected here -->
                    </div>
                </div>

                <!-- Country Filter -->
                <div class="w-1/2 sm:w-full">
                    <label class="text-text-muted text-sm font-semibold block mb-2">Filter by Country:</label>
                    
                    <!-- Mobile Dropdown -->
                    <select id="tv-country-dropdown" class="sm:hidden w-full bg-secondary-dark text-text-light rounded-lg p-2.5 focus:ring-accent focus:border-accent border border-gray-700" onchange="changeCountry('tv', this.value)">
                        <!-- Options injected here -->
                    </select>
                    
                    <!-- Desktop Buttons -->
                    <div id="tv-country-filters" class="hidden sm:flex flex-wrap gap-2">
                        <!-- Country buttons injected here -->
                    </div>
                </div>
            </div>

            <div id="popular-tv-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6">
                <!-- Content will be injected here -->
            </div>
            <!-- Pagination Controls for TV Shows -->
            <div id="popular-tv-pagination" class="mt-6 flex justify-center"></div>
        </section>
        
        <!-- Removed Popular Anime Section -->
    </main>
    
    <!-- Fixed Bottom Navigation (Mobile Only) -->
    <footer id="mobile-nav-footer" class="fixed bottom-0 left-0 right-0 bg-secondary-dark sm:hidden z-40 border-t border-gray-700 shadow-2xl">
        <nav class="flex justify-around items-center h-16 text-xs text-text-muted">
            <!-- Movies -->
            <button onclick="navigateTo('popular-movies-section', 1)" class="flex flex-col items-center justify-center p-2 mobile-nav-item" data-section-id="popular-movies-section">
                <!-- Film Icon (Lucide) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line></svg>
                <span class="mt-0.5 font-medium">Movies</span>
            </button>
            <!-- TV Shows -->
            <button onclick="navigateTo('popular-tv-section', 1)" class="flex flex-col items-center justify-center p-2 mobile-nav-item" data-section-id="popular-tv-section">
                <!-- TV Icon (Lucide) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline></svg>
                <span class="mt-0.5 font-medium">TV Shows</span>
            </button>
            <!-- Removed Anime Button -->
        </nav>
    </footer>

    <!-- Modal for details (hidden by default) -->
    <div id="detail-modal" class="fixed inset-0 bg-black bg-opacity-80 z-50 hidden items-center justify-center p-4" onclick="closeModal(event)">
        <!-- Modal content is now inside a scrolling wrapper -->
        <div id="modal-content" class="bg-secondary-dark rounded-xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
            <!-- Modal content injected here -->
        </div>
    </div>


    <script>
        // Constants for API access
        const API_KEY = '5c7ced332aa33d7507e5d53bd818a963';
        const BASE_URL = 'https://api.themoviedb.org/3';
        const IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500';
        
        // --- STREAMING SOURCE CONFIGURATION ---
        const STREAM_SOURCES = [
            { url: 'https://vidlink.pro', name: 'Source A' },
            { url: 'https://vidsrcme.su/embed/', name: 'Source B' },
            { url: 'https://vidsrc.cc/v2/embed/', name: 'Source C' },
            { url: 'https://player.videasy.net', name: 'Source D' }
        ];
        let activeStreamSourceIndex = 0; // Index of the currently active source (0 = default, 1 = backup)
        // ----------------------------------------

        // --- COMPLETE TMDb GENRE LIST ---
        const GENRES = [
            { id: '', name: 'All Genres' }, // Changed name for clarity in dropdown
            { id: 28, name: 'Action' },
            { id: 12, name: 'Adventure' },
            { id: 16, name: 'Animation' },
            { id: 35, name: 'Comedy' },
            { id: 80, name: 'Crime' },
            { id: 99, name: 'Documentary' },
            { id: 18, name: 'Drama' },
            { id: 10751, name: 'Family' },
            { id: 14, name: 'Fantasy' },
            { id: 36, name: 'History' },
            { id: 27, name: 'Horror' },
            { id: 10402, name: 'Music' },
            { id: 9648, name: 'Mystery' },
            { id: 10749, name: 'Romance' },
            { id: 878, name: 'Science Fiction' },
            { id: 10770, name: 'TV Movie' },
            { id: 53, name: 'Thriller' },
            { id: 10752, name: 'War' },
            { id: 37, name: 'Western' },
        ];
        
        // --- EXPANDED COUNTRY LIST (Origin Country Codes) ---
        const COUNTRIES = [
            { code: '', name: 'All Countries' }, // Changed name for clarity in dropdown
            { code: 'US', name: 'United States' },
            { code: 'GB', name: 'United Kingdom' },
            { code: 'IN', name: 'India (Bollywood)' },
            { code: 'KR', name: 'South Korea (K-Drama)' },
            { code: 'JP', name: 'Japan' },
            { code: 'CA', name: 'Canada' },
            { code: 'AU', name: 'Australia' },
            { code: 'FR', name: 'France' },
            { code: 'DE', name: 'Germany' },
            { code: 'ES', name: 'Spain' },
            { code: 'MX', name: 'Mexico' },
            { code: 'BR', name: 'Brazil' },
            { code: 'CN', name: 'China' },
            { code: 'IT', 'name': 'Italy' },
            { code: 'NL', name: 'Netherlands' },
            { code: 'SE', name: 'Sweden' },
            { code: 'PL', name: 'Poland' },
            { code: 'RU', name: 'Russia' },
            { code: 'TR', name: 'Turkey' },
            { code: 'HK', name: 'Hong Kong' },
            { code: 'IR', name: 'Iran' },
            { code: 'ZA', name: 'South Africa' },
            { code: 'AR', name: 'Argentina' },
            { code: 'DK', name: 'Denmark' },
            { code: 'NO', name: 'Norway' },
            { code: 'BE', name: 'Belgium' },
            { code: 'PH', name: 'Philippines' },
            { code: 'TH', name: 'Thailand' },
        ];


        // Global state for the currently displayed media details
        let currentMediaDetails = null;
        
        // Global State for Pagination
        const currentPage = {
            'movie': 1,
            'tv': 1,
            'search': 1
        };
        const totalPages = {
            'movie': 1,
            'tv': 1,
            'search': 1
        };
        
        // GLOBAL STATE FOR SORTING AND FILTERING
        const currentSort = {
            'movie': 'popularity',
            'tv': 'popularity',
        };
        
        const currentFilter = {
            'movie': { genreId: '', countryCode: '' },
            'tv': { genreId: '', countryCode: '' },
        };

        let currentQuery = ''; // To store the last search query for pagination

        // DOM elements
        const popularMoviesContainer = document.getElementById('popular-movies-container');
        const popularTvContainer = document.getElementById('popular-tv-container');
        const searchResultsContainer = document.getElementById('search-results-container');
        const searchResultsSection = document.getElementById('search-results-section');
        const popularMoviesSection = document.getElementById('popular-movies-section');
        const popularTvSection = document.getElementById('popular-tv-section');
        const statusMessage = document.getElementById('status-message');
        const detailModal = document.getElementById('detail-modal');
        const modalContent = document.getElementById('modal-content');
        
        // NEW DOM Elements for UI Refactor
        const searchInputDesktop = document.getElementById('search-input-desktop');
        const searchInputMobile = document.getElementById('search-input-mobile');
        const mobileSearchOverlay = document.getElementById('mobile-search-filter-overlay');
        const desktopNavLinks = document.querySelectorAll('#desktop-nav .nav-link'); 
        const mobileNavItems = document.querySelectorAll('.mobile-nav-item');


        /**
         * Helper function to show and hide status messages (errors, no results).
         * @param {string} message The message to display.
         * @param {string} type 'error' or 'info'.
         */
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden', 'bg-red-800', 'bg-blue-800');
            statusMessage.classList.add(type === 'error' ? 'bg-red-800' : 'bg-blue-800');
        }

        /**
         * Clears the status message area.
         */
        function clearStatus() {
            statusMessage.classList.add('hidden');
            statusMessage.textContent = '';
        }

        /**
         * Generic function to fetch data from the TMDb API.
         * Implements exponential backoff for resilience.
         * @param {string} endpoint The API endpoint (e.g., '/movie/popular').
         * @param {string} queryParams Additional query string parameters (optional).
         * @param {number} retries Current retry count.
         */
        async function fetchData(endpoint, queryParams = '', retries = 0) {
            const url = `${BASE_URL}${endpoint}?api_key=${API_KEY}&${queryParams}`;
            const maxRetries = 3;

            try {
                const response = await fetch(url);

                if (!response.ok) {
                    if (response.status === 429 && retries < maxRetries) {
                        // Rate limit hit, retry with exponential backoff
                        const delay = Math.pow(2, retries) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return fetchData(endpoint, queryParams, retries + 1);
                    }
                    throw new Error(`TMDb API Error: ${response.status} ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                showStatus(`Failed to fetch data: ${error.message}. Please check your API key or network connection.`, 'error');
                return null;
            }
        }

        /**
         * Renders a loading skeleton for a poster card.
         * @returns {string} HTML string for the loading skeleton.
         */
        function createLoadingSkeleton() {
            return `
                <div class="bg-gray-700 rounded-xl overflow-hidden shadow-xl animate-pulse loading-card">
                    <div class="aspect-[2/3] bg-gray-600"></div>
                    <div class="p-3">
                        <div class="h-4 bg-gray-500 rounded w-3/4 mb-2"></div>
                        <div class="h-3 bg-gray-500 rounded w-1/2"></div>
                    </div>
                </div>
            `;
        }

        /**
         * Generates and inserts poster cards into the specified container.
         * @param {HTMLElement} container The container to append cards to.
         * @param {Array<Object>} items The list of movies/shows.
         * @param {string} mediaType 'movie' or 'tv' (fallback for initial loads).
         */
        function renderCards(container, items, mediaType) {
            container.innerHTML = ''; // Clear previous content

            if (!items || items.length === 0) {
                container.innerHTML = `<p class="text-text-muted col-span-full text-center py-8">No results found.</p>`;
                return;
            }

            items.forEach(item => {
                const title = item.title || item.name || 'Untitled';
                const releaseDate = item.release_date || item.first_air_date;
                const year = releaseDate ? new Date(releaseDate).getFullYear() : 'N/A';
                const posterPath = item.poster_path;
                const fullPosterUrl = posterPath ? `${IMAGE_BASE_URL}${posterPath}` : 'https://placehold.co/500x750/374151/ffffff?text=Poster+Unavailable';
                const cardMediaType = item.media_type || (mediaType === 'movie' ? 'movie' : 'tv');

                const cardHtml = `
                    <div
                        class="poster-card bg-secondary-dark rounded-xl overflow-hidden shadow-xl"
                        data-id="${item.id}"
                        data-type="${cardMediaType}"
                        onclick="showDetails(this.dataset.id, this.dataset.type)"
                    >
                        <!-- Poster Image -->
                        <div class="aspect-[2/3] overflow-hidden">
                            <img
                                src="${fullPosterUrl}"
                                alt="${title} poster"
                                class="w-full h-full object-cover"
                                onerror="this.onerror=null; this.src='https://placehold.co/500x750/374151/ffffff?text=Poster+Unavailable';"
                                loading="lazy"
                            >
                        </div>
                        <!-- Card Footer/Details -->
                        <div class="p-3 text-center">
                            <p class="text-sm font-medium truncate text-text-light" title="${title}">${title}</p>
                            <p class="text-xs text-text-muted mt-0.5">${year}</p>
                        </div>
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', cardHtml);
            });
        }
        
        /**
         * Renders the pagination controls below the content.
         * @param {HTMLElement} container The container for pagination buttons.
         * @param {string} mediaType The type ('movie', 'tv', 'search').
         * @param {number} current The current page number.
         * @param {number} total The total pages available (max 500).
         */
        function renderPagination(container, mediaType, current, total) {
            container.innerHTML = '';
            if (total <= 1) return;

            // Helper to create buttons
            const createButton = (text, page, isActive = false, isDisabled = false) => {
                const button = document.createElement('button');
                button.textContent = text;
                button.disabled = isDisabled;
                button.className = `px-3 py-2 mx-1 rounded-lg font-medium transition duration-200 focus:outline-none 
                                    ${isActive 
                                        ? 'bg-accent text-text-light shadow-md' 
                                        : 'bg-secondary-dark text-text-light hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'}`;
                
                if (!isDisabled && !isActive) {
                    button.onclick = () => {
                        // If search, re-run search with the specific page. Otherwise, fetch the media type page.
                        if (mediaType === 'search') {
                            handleSearch(page, currentQuery); // Re-run search using the stored query
                        } else {
                            fetchAndRender(mediaType, page);
                        }
                    };
                }
                return button;
            };
            
            // Add Previous Button
            // container.appendChild(createButton('Previous', current - 1, false, current === 1));

            // Logic to determine which page numbers to show (e.g., 1, ..., 4, 5, 6, ..., 500)
            let startPage = Math.max(1, current - 2);
            let endPage = Math.min(total, current + 2);

            if (current <= 3) endPage = Math.min(5, total);
            if (current > total - 3) startPage = Math.max(1, total - 4);

            // Show first page and ellipsis if needed
            if (startPage > 1) {
                container.appendChild(createButton('1', 1));
                if (startPage > 2) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    ellipsis.className = 'px-2 py-2 text-text-muted';
                    container.appendChild(ellipsis);
                }
            }

            // Show main page numbers
            for (let i = startPage; i <= endPage; i++) {
                container.appendChild(createButton(i.toString(), i, i === current));
            }

            // Show ellipsis and last page if needed
            if (endPage < total) {
                if (endPage < total - 1) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    ellipsis.className = 'px-2 py-2 text-text-muted';
                    container.appendChild(ellipsis);
                }
                container.appendChild(createButton(total.toString(), total));
            }

            // Add Next Button
            // container.appendChild(createButton('Next', current + 1, false, current === total));
        }

        /**
         * Toggles the sort filter for a media type and triggers a content refresh.
         * @param {string} mediaType The type ('movie', 'tv').
         * @param {string} sortBy 'popularity' or 'release_date'.
         */
        function changeSort(mediaType, sortBy) {
            if (currentSort[mediaType] === sortBy) return; // Already sorted by this value
            
            currentSort[mediaType] = sortBy;
            currentPage[mediaType] = 1; // Always reset to page 1 when changing sort
            
            // Update button styles
            const filterContainer = document.getElementById(`${mediaType}-sort-filters`);
            if (filterContainer) {
                filterContainer.querySelectorAll('.sort-button').forEach(button => {
                    if (button.dataset.sort === sortBy) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }

            // Fetch and render new content
            fetchAndRender(mediaType, 1);
        }
        
        /**
         * Toggles the genre filter for a media type and triggers a content refresh.
         * @param {string} mediaType The type ('movie', 'tv').
         * @param {string} genreId The genre ID (or '' for All).
         */
        function changeGenre(mediaType, genreId) {
            // Convert to string for consistent comparison if coming from dropdown (string) or button (string)
            const newGenreId = String(genreId); 

            if (currentFilter[mediaType].genreId === newGenreId) return; // Already selected
            
            currentFilter[mediaType].genreId = newGenreId;
            currentPage[mediaType] = 1; // Always reset to page 1 when changing filter
            
            // 1. Update Desktop Button styles
            const buttonContainer = document.getElementById(`${mediaType}-genre-filters`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.filter-button').forEach(button => {
                    if (button.dataset.value === newGenreId) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
            
            // 2. Update Mobile Dropdown value
            const dropdown = document.getElementById(`${mediaType}-genre-dropdown`);
            if (dropdown) {
                dropdown.value = newGenreId;
            }

            // Fetch and render new content
            fetchAndRender(mediaType, 1);
        }
        
        /**
         * Toggles the country filter for a media type and triggers a content refresh.
         * @param {string} mediaType The type ('movie', 'tv').
         * @param {string} countryCode The country code (or '' for All).
         */
        function changeCountry(mediaType, countryCode) {
            const newCountryCode = String(countryCode);
            
            if (currentFilter[mediaType].countryCode === newCountryCode) return; // Already selected
            
            currentFilter[mediaType].countryCode = newCountryCode;
            currentPage[mediaType] = 1; // Always reset to page 1 when changing filter
            
            // 1. Update Desktop Button styles
            const buttonContainer = document.getElementById(`${mediaType}-country-filters`);
            if (buttonContainer) {
                buttonContainer.querySelectorAll('.filter-button').forEach(button => {
                    if (button.dataset.value === newCountryCode) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
            
            // 2. Update Mobile Dropdown value
            const dropdown = document.getElementById(`${mediaType}-country-dropdown`);
            if (dropdown) {
                dropdown.value = newCountryCode;
            }

            // Fetch and render new content
            fetchAndRender(mediaType, 1);
        }

        /**
         * Renders the genre/country filter buttons AND dropdowns into the specified containers.
         * @param {string} mediaType The media type ('movie', 'tv').
         * @param {string} filterType 'genre' or 'country'.
         */
        function renderFilterButtons(mediaType, filterType) {
            const containerId = `${mediaType}-${filterType}-filters`;
            const dropdownId = `${mediaType}-${filterType}-dropdown`;

            const container = document.getElementById(containerId);
            const dropdown = document.getElementById(dropdownId);
            
            if (!container || !dropdown) return;

            container.innerHTML = ''; // Clear previous button content
            dropdown.innerHTML = ''; // Clear previous dropdown options
            
            let data, action, currentActive;

            if (filterType === 'genre') {
                data = GENRES;
                action = `changeGenre('${mediaType}', this.dataset.value)`;
                currentActive = currentFilter[mediaType].genreId;
            } else if (filterType === 'country') {
                data = COUNTRIES; 
                action = `changeCountry('${mediaType}', this.dataset.value)`;
                currentActive = currentFilter[mediaType].countryCode;
            } else {
                return;
            }

            data.forEach(item => {
                const value = filterType === 'genre' ? item.id.toString() : item.code;
                const isActive = value === currentActive.toString();
                
                // 1. Generate button for desktop
                const buttonHtml = `
                    <button 
                        class="filter-button ${isActive ? 'active' : ''}" 
                        data-type="${mediaType}" 
                        data-filter="${filterType}" 
                        data-value="${value}"
                        onclick="${action}"
                        title="${filterType === 'country' ? item.code : ''}"
                    >
                        ${item.name}
                    </button>
                `;
                container.insertAdjacentHTML('beforeend', buttonHtml);
                
                // 2. Generate option for mobile dropdown
                const option = document.createElement('option');
                option.value = value;
                option.textContent = item.name;
                if (isActive) {
                    option.selected = true;
                }
                dropdown.appendChild(option);
            });
        }


        /**
         * Central function to handle fetching, rendering cards, and rendering pagination.
         * @param {string} mediaType The type ('movie', 'tv', 'search').
         * @param {number} page The page number to fetch.
         * @param {string} query The search query (only for 'search' type).
         */
        async function fetchAndRender(mediaType, page = 1, query = '') {
            // 1. Determine API endpoint and container
            let endpoint = '';
            let containerId, paginationContainerId, queryParams = 'language=en-US';

            // Determine base parameters for Discover endpoint
            if (mediaType === 'movie') {
                endpoint = '/discover/movie';
                containerId = 'popular-movies-container';
                paginationContainerId = 'popular-movies-pagination';
            } else if (mediaType === 'tv') {
                endpoint = '/discover/tv';
                containerId = 'popular-tv-container';
                paginationContainerId = 'popular-tv-pagination';
            } else if (mediaType === 'search') {
                endpoint = '/search/multi';
                // Always keep search safe for adult content
                queryParams += `&query=${encodeURIComponent(query)}&include_adult=false`; 
                containerId = 'search-results-container';
                paginationContainerId = 'search-results-pagination';
            } else {
                return; // Invalid media type
            }
            
            // Apply sorting and filtering logic for non-search types
            if (mediaType !== 'search') {
                const sortParam = currentSort[mediaType];
                const filter = currentFilter[mediaType];

                // 1. Apply Sorting (Release Date vs. Popularity)
                if (sortParam === 'popularity') {
                    queryParams += '&sort_by=popularity.desc';
                } else if (sortParam === 'release_date') {
                    const dateType = mediaType === 'movie' ? 'primary_release_date' : 'first_air_date';
                    queryParams += `&sort_by=${dateType}.desc`;
                }

                // 2. Apply Genre Filter
                if (filter.genreId) {
                    queryParams += `&with_genres=${filter.genreId}`;
                }

                // 3. Apply Country Filter (using 'with_origin_country')
                if (filter.countryCode) {
                    queryParams += `&with_origin_country=${filter.countryCode}`;
                }
                
                // 4. TMDb API defaults to excluding adult content unless explicitly requested.
            }


            // Get containers
            const container = document.getElementById(containerId);
            const paginationContainer = document.getElementById(paginationContainerId);
            
            // Show loading state
            container.innerHTML = Array(6).fill(createLoadingSkeleton()).join('');
            paginationContainer.innerHTML = ''; // Clear pagination while loading
            clearStatus();

            // 2. Fetch data
            queryParams += `&page=${page}`;
            const data = await fetchData(endpoint, queryParams);
            
            // Scroll to the top of the page after fetching new content
            window.scrollTo(0, 0);

            // 3. Update State and Render Content
            if (data && data.results) {
                currentPage[mediaType] = data.page;
                // Limit total pages to 500 as per TMDb API documentation best practices
                totalPages[mediaType] = Math.min(data.total_pages, 500); 

                let itemsToRender = data.results;

                if (mediaType === 'search') {
                    currentQuery = query; // Update query for search context
                    itemsToRender = data.results.filter(item =>
                        (item.media_type === 'movie' || item.media_type === 'tv') && item.poster_path
                    );
                    if (itemsToRender.length === 0) {
                        showStatus(`No movies or TV shows found for "${query}" on page ${page}.`, 'info');
                    }
                } 
                
                if (itemsToRender.length === 0) {
                    container.innerHTML = `<p class="text-text-muted col-span-full text-center py-8">
                                            No results found for the current sort and filter combination.
                                        </p>`;
                } else {
                    renderCards(container, itemsToRender, mediaType);
                }
                
                // 4. Render Pagination Controls
                if (data.total_results > 0) {
                    renderPagination(paginationContainer, mediaType, currentPage[mediaType], totalPages[mediaType]);
                }
                
            } else {
                container.innerHTML = `<p class="text-center text-red-400 col-span-full">Could not load content.</p>`;
            }
        }
        
        // --- NEW STREAMING FUNCTIONS ---

        /**
         * Generates the full stream URL based on media details and selected source.
         * @param {string} id TMDb ID.
         * @param {string} type 'movie' or 'tv'.
         * @param {number} sourceIndex Index of the source in STREAM_SOURCES.
         * @param {number} season Season number (for TV).
         * @param {number} episode Episode number (for TV).
         * @returns {string} The full stream URL.
         */
        function generateStreamUrl(id, type, sourceIndex = activeStreamSourceIndex, season = 1, episode = 1) {
            const baseUrl = STREAM_SOURCES[sourceIndex].url;
            if (type === 'movie') {
                return `${baseUrl}/movie/${id}`;
            } else if (type === 'tv') {
                return `${baseUrl}/tv/${id}/${season}/${episode}`;
            }
            return '';
        }

        /**
         * Switches the active stream source and updates the player iframe.
         * @param {number} newSourceIndex The index of the source to switch to.
         */
        function switchStreamSource(newSourceIndex) {
            if (newSourceIndex === activeStreamSourceIndex) return;

            activeStreamSourceIndex = newSourceIndex;
            
            // Update button styles
            document.querySelectorAll('.stream-source-button').forEach((btn, index) => {
                if (index === activeStreamSourceIndex) {
                    btn.classList.add('active-source-button');
                    btn.classList.remove('inactive-source-button');
                } else {
                    btn.classList.remove('active-source-button');
                    btn.classList.add('inactive-source-button');
                }
            });

            // Re-generate and load the stream URL using current media details
            if (currentMediaDetails) {
                const id = currentMediaDetails.id;
                const type = currentMediaDetails.media_type || (currentMediaDetails.title ? 'movie' : 'tv');
                
                const seasonSelect = document.getElementById('season-select');
                const episodeSelect = document.getElementById('episode-select');
                let season = 1;
                let episode = 1;

                if (type === 'tv' && seasonSelect && episodeSelect) {
                    season = parseInt(seasonSelect.value) || 1;
                    episode = parseInt(episodeSelect.value) || 1;
                }

                const newStreamUrl = generateStreamUrl(id, type, activeStreamSourceIndex, season, episode);
                const iframe = document.getElementById('stream-iframe');
                if (iframe) {
                    iframe.src = newStreamUrl;
                    console.log(`Switched to ${STREAM_SOURCES[newSourceIndex].name}:`, newStreamUrl);
                }
            }
        }
        
        // --- TV CONTROLS (Updated to use activeStreamSourceIndex) ---

        function updateEpisodeDropdown(seasonsData, selectedSeason, defaultEpisode = 1) {
            const episodeSelect = document.getElementById('episode-select');
            if (!episodeSelect) return;

            episodeSelect.innerHTML = ''; // Clear previous episodes
            
            const season = seasonsData.find(s => s.season_number === selectedSeason);
            
            if (season && season.episode_count > 0) {
                const maxEpisodes = season.episode_count;
                const episodeToSelect = Math.min(maxEpisodes, defaultEpisode); 
                
                for (let i = 1; i <= maxEpisodes; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `E${i}`;
                    if (i === episodeToSelect) {
                        option.selected = true;
                    }
                    episodeSelect.appendChild(option);
                }
                episodeSelect.disabled = false;
            } else {
                const option = document.createElement('option');
                option.value = 1;
                option.textContent = 'No Episodes';
                episodeSelect.appendChild(option);
                episodeSelect.disabled = true;
            }
        }

        function generateTvStreamUrl(id) {
            const seasonSelect = document.getElementById('season-select');
            const episodeSelect = document.getElementById('episode-select');
            const iframe = document.getElementById('stream-iframe');

            if (!seasonSelect || !episodeSelect || !iframe) return;

            const season = parseInt(seasonSelect.value) || 1;
            const episode = parseInt(episodeSelect.value) || 1;

            // Use the global state for the source index
            const newStreamUrl = generateStreamUrl(id, 'tv', activeStreamSourceIndex, season, episode);
            
            iframe.src = newStreamUrl;
            console.log('Updated TV stream URL:', newStreamUrl);
        }

        function initializeTvControls(seasonsData, id) {
            const seasonSelect = document.getElementById('season-select');
            const episodeSelect = document.getElementById('episode-select');

            if (!seasonSelect || !episodeSelect) return;

            seasonSelect.innerHTML = '';
            let defaultSeason = 1;

            if (seasonsData.length > 0) {
                const latestValidSeason = seasonsData
                    .filter(s => s.season_number > 0)
                    .sort((a, b) => b.season_number - a.season_number)[0];
                
                defaultSeason = latestValidSeason ? latestValidSeason.season_number : 1;

                seasonsData.forEach(season => {
                    const option = document.createElement('option');
                    option.value = season.season_number;
                    option.textContent = `${season.name} (S${season.season_number})`;
                    if (season.season_number === defaultSeason) {
                        option.selected = true;
                    }
                    seasonSelect.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = 1;
                option.textContent = 'Season 1 (Default)';
                seasonSelect.appendChild(option);
            }

            updateEpisodeDropdown(seasonsData, defaultSeason, 1);
            generateTvStreamUrl(id);

            seasonSelect.addEventListener('change', () => {
                const selectedSeason = parseInt(seasonSelect.value);
                updateEpisodeDropdown(seasonsData, selectedSeason, 1);
                generateTvStreamUrl(id);
            });

            episodeSelect.addEventListener('change', () => {
                generateTvStreamUrl(id);
            });
        }

        function openStream(id, type) {
            const detailsContainer = document.getElementById('details-metadata-container');
            const playerContainer = document.getElementById('video-player-container');
            const posterColumn = document.getElementById('poster-column');
            const closeDetailsButton = document.getElementById('close-details-button');
            
            // Default to the primary source when opening the player
            activeStreamSourceIndex = 0; 

            let streamUrl = '';
            let playerControlsHtml = '';
            let seasonsData = [];
            
            // Determine initial stream URL
            if (type === 'movie') {
                streamUrl = generateStreamUrl(id, 'movie', activeStreamSourceIndex);
            } else if (type === 'tv') {
                if (currentMediaDetails && currentMediaDetails.seasons) {
                    seasonsData = currentMediaDetails.seasons
                        .filter(s => s.season_number >= 1 && s.episode_count > 0);
                }
                
                streamUrl = generateStreamUrl(id, 'tv', activeStreamSourceIndex); // Placeholder, will be re-set by initializeTvControls

                playerControlsHtml = `
                    <div class="flex flex-wrap items-center space-x-4 mb-4 bg-gray-800 p-3 rounded-lg shadow">
                        <label class="text-text-light text-sm font-semibold">Select Episode:</label>
                        
                        <div class="flex items-center space-x-2">
                            <label class="text-text-muted text-sm" for="season-select">Season:</label>
                            <select id="season-select" class="bg-gray-700 text-text-light rounded-md p-1.5 focus:ring-accent focus:outline-none"></select>
                        </div>
                        
                        <div class="flex items-center space-x-2">
                            <label class="text-text-muted text-sm" for="episode-select">Episode:</label>
                            <select id="episode-select" class="bg-gray-700 text-text-light rounded-md p-1.5 focus:ring-accent focus:outline-none"></select>
                        </div>
                    </div>
                `;
            }

            detailsContainer.classList.add('hidden');
            posterColumn.classList.add('hidden'); 

            playerContainer.classList.remove('md:w-2/3');
            playerContainer.classList.add('md:w-full'); 
            
            playerContainer.classList.remove('hidden');

            // NEW Stream Source Switcher UI
            let sourceSwitcherHtml = `
                <div class="mb-4">
                    <label class="text-text-muted text-xs font-semibold block mb-1">Select Stream Source:</label>
                    <div class="flex space-x-2">
                        ${STREAM_SOURCES.map((source, index) => `
                            <button 
                                class="stream-source-button px-1 py-1 text-sm rounded-lg transition duration-200 
                                        ${index === activeStreamSourceIndex ? 'active-source-button' : 'inactive-source-button'}"
                                onclick="switchStreamSource(${index})"
                            >
                                ${source.name}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
            
            playerContainer.innerHTML = `
                <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h4 class="text-xl font-semibold text-text-light">Streaming Player</h4>
                    <button class="text-text-muted hover:text-accent text-sm font-medium" onclick="showDetails('${id}', '${type}', true)">
                        ← Back to Details
                    </button>
                </div>
                
                ${sourceSwitcherHtml}

                ${playerControlsHtml}

                <div class="aspect-video w-full mb-4 rounded-lg overflow-hidden shadow-2xl">
                    <iframe
                        id="stream-iframe"
                        src="${streamUrl}"
                        width="100%"
                        height="100%"
                        frameborder="0"
                        allowfullscreen
                        autoplay="1"
                        allow="encrypted-media"
                        referrerpolicy="origin"
                    ></iframe>
                </div>
            `;
            modalContent.scrollTop = 0;
            
            if (type === 'tv') {
                initializeTvControls(seasonsData, id); 
            }

            if(closeDetailsButton) closeDetailsButton.classList.remove('hidden');
        }

        async function showDetails(id, type, returningFromStream = false) {
            window.scrollTo(0, 0); 

            let itemDetails = currentMediaDetails;

            if (!returningFromStream || !itemDetails || itemDetails.id != id) {
                 // 1. Show loading state
                modalContent.innerHTML = `
                    <div class="p-8 flex justify-center items-center h-48">
                        <svg class="animate-spin h-8 w-8 text-accent" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p class="ml-4 text-lg">Loading details...</p>
                    </div>
                `;
                detailModal.classList.remove('hidden');
                detailModal.classList.add('flex');
                
                currentMediaDetails = null;

                // 2. Fetch details, including credits (cast) via append_to_response
                itemDetails = await fetchData(`/${type}/${id}`, 'language=en-US&append_to_response=credits');
                
                if (!itemDetails) {
                    modalContent.innerHTML = `<div class="p-6 text-center text-red-400">Failed to load details.</div>`;
                    return;
                }
                
                currentMediaDetails = itemDetails;
            } else {
                detailModal.classList.remove('hidden');
                detailModal.classList.add('flex');
            }


            // 3. Format data
            const title = itemDetails.title || itemDetails.name || 'Untitled';
            const posterPath = itemDetails.poster_path;
            const fullPosterUrl = posterPath ? `${IMAGE_BASE_URL}${posterPath}` : 'https://placehold.co/500x750/374151/ffffff?text=Poster+Unavailable';
            const overview = itemDetails.overview || 'No overview available.';
            const tagline = itemDetails.tagline || '';
            const rating = itemDetails.vote_average ? itemDetails.vote_average.toFixed(1) : 'N/A';
            const genres = itemDetails.genres ? itemDetails.genres.map(g => g.name).join(', ') : 'N/A';
            const runtime = itemDetails.runtime ? `${itemDetails.runtime} min` : (itemDetails.episode_run_time ? `${itemDetails.episode_run_time[0]} min (Ep)` : 'N/A');
            const release = itemDetails.release_date || itemDetails.first_air_date || 'N/A';
            const status = itemDetails.status || 'N/A';
            const networks = itemDetails.networks ? itemDetails.networks.map(n => n.name).join(', ') : 'N/A';
            const lastAirDate = itemDetails.last_air_date || 'N/A';
            const totalSeasons = itemDetails.number_of_seasons || 'N/A';
            const totalEpisodes = itemDetails.number_of_episodes || 'N/A';

            const displayType = type === 'movie' ? 'Movie' : 'TV Show';
            
            let tvMetadataHtml = '';
            if (type === 'tv') {
                tvMetadataHtml = `
                    <p><span class="text-text-muted">Status:</span> ${status}</p>
                    <p><span class="text-text-muted">Networks:</span> ${networks}</p>
                    <p><span class="text-text-muted">Seasons:</span> ${totalSeasons}</p>
                    <p><span class="text-text-muted">Total Episodes:</span> ${totalEpisodes}</p>
                    <p><span class="text-text-muted">Last Aired:</span> ${lastAirDate}</p>
                `;
            }

            // --- CAST PROCESSING ---
            // Get the top 8 cast members
            const cast = itemDetails.credits?.cast ? itemDetails.credits.cast.slice(0, 8) : [];
            let castHtml = '';

            if (cast.length > 0) {
                castHtml = `
                    <h4 class="text-xl font-semibold text-text-light mb-4 mt-6 border-b border-gray-700 pb-2">Main Cast</h4>
                    <div class="grid grid-cols-4 sm:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-4">
                        ${cast.map(member => {
                            const profilePath = member.profile_path;
                            const fullProfileUrl = profilePath ? `${IMAGE_BASE_URL}${profilePath}` : 'https://placehold.co/500x750/374151/ffffff?text=No+Photo';
                            return `
                                <div class="flex flex-col items-center text-center">
                                    <img 
                                        src="${fullProfileUrl}" 
                                        alt="${member.name}" 
                                        class="w-full h-auto aspect-square object-cover rounded-full border-2 border-gray-600"
                                        onerror="this.onerror=null; this.src='https://placehold.co/500x500/374151/ffffff?text=No+Photo';"
                                        loading="lazy"
                                    >
                                    <p class="text-xs font-medium text-text-light mt-1 truncate w-full" title="${member.name}">${member.name}</p>
                                    <p class="text-xs text-text-muted italic truncate w-full" title="${member.character}">${member.character || 'N/A'}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }
            // --- END CAST PROCESSING ---

            // 5. Inject content
            modalContent.innerHTML = `
                <div class="p-6">
                    <div class="flex flex-col md:flex-row space-y-6 md:space-y-0 md:space-x-6">
                        
                        <!-- Player Container (Will be hidden initially, shown when 'Watch Now' is clicked, full width when active) -->
                        <div id="video-player-container" class="w-full hidden md:w-2/3">
                            <!-- Player content injected here by openStream() -->
                        </div>

                        <!-- Details Container (visible by default) -->
                        <div id="details-metadata-container" class="w-full md:w-2/3">
                            <h3 class="text-4xl font-bold text-text-light mb-1">${title}</h3>
                            ${tagline ? `<p class="text-accent italic mb-4 text-lg">${tagline}</p>` : ''}

                            <!-- Metadata Grid -->
                            <div class="grid grid-cols-2 gap-y-2 gap-x-4 text-sm mb-6 border-b border-gray-700 pb-4">
                                <p><span class="text-text-muted">Type:</span> ${displayType}</p>
                                <p><span class="text-text-muted">Rating:</span>
                                    <span class="font-bold text-yellow-400">★ ${rating}</span> / 10
                                </p>
                                <p><span class="text-text-muted">Release Date:</span> ${release}</p>
                                <p><span class="text-text-muted">${type === 'movie' ? 'Runtime:' : 'Episode Time:'}</span> ${runtime}</p>
                                ${tvMetadataHtml}
                                <p class="col-span-2"><span class="text-text-muted">Genres:</span> ${genres}</p>
                            </div>

                            <!-- Overview -->
                            <h4 class="text-xl font-semibold text-text-light mb-2">Synopsis</h4>
                            <p class="text-text-muted leading-relaxed">${overview}</p>
                            
                            <!-- Cast List -->
                            ${castHtml}
                        </div>
                        
                        <!-- Poster and Watch Button Column -->
                        <div id="poster-column" class="w-full md:w-1/3 flex-shrink-0 order-first md:order-last">
                            <img src="${fullPosterUrl}" alt="${title} poster" class="w-full rounded-lg shadow-xl" onerror="this.onerror=null; this.src='https://placehold.co/500x750/374151/ffffff?text=Poster+Unavailable';">
                            <button 
                                id="watch-button"
                                class="mt-4 w-full bg-accent hover:bg-red-600 text-text-light font-bold py-3 rounded-lg shadow-lg transition duration-300 transform hover:scale-[1.01] focus:outline-none focus:ring-2 focus:ring-accent"
                                onclick="openStream('${id}', '${type}')"
                            >
                                Watch Now!
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Close Button -->
                <button id="close-details-button" class="absolute top-4 right-4 text-text-muted hover:text-accent transition duration-200" onclick="closeModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            `;

            const detailsDiv = document.getElementById('details-metadata-container');
            const playerDiv = document.getElementById('video-player-container');
            const posterDiv = document.getElementById('poster-column');

            if(detailsDiv) detailsDiv.classList.remove('hidden');
            if(playerDiv) playerDiv.classList.add('hidden');
            if(posterDiv) posterDiv.classList.remove('hidden');
            if(playerDiv) playerDiv.classList.remove('md:w-full');
            if(playerDiv) playerDiv.classList.add('md:w-2/3');
            if(detailsDiv) detailsDiv.classList.remove('md:w-full');
            if(detailsDiv) detailsDiv.classList.add('md:w-2/3');
            
            if(playerDiv) playerDiv.classList.add('hidden');
        }

        function closeModal(event) {
            if (!event || event.target === detailModal) {
                const streamIframe = document.getElementById('stream-iframe');
                if (streamIframe) {
                    streamIframe.src = ''; 
                    console.log('Stream iframe source cleared to stop playback.');
                }

                detailModal.classList.add('hidden');
                detailModal.classList.remove('flex');
                
                currentMediaDetails = null;
            }
        }
        
        // --- UI/NAVIGATION FUNCTIONS ---

        function toggleMobileSearchOverlay(forceState = null) {
            const isHidden = mobileSearchOverlay.classList.contains('-translate-y-full');
            const newState = forceState !== null ? forceState : isHidden;

            if (newState) {
                mobileSearchOverlay.classList.remove('-translate-y-full', 'opacity-0', 'pointer-events-none');
                mobileSearchOverlay.classList.add('translate-y-0', 'opacity-100', 'pointer-events-auto');
                if (searchInputMobile) searchInputMobile.focus();
            } else {
                mobileSearchOverlay.classList.remove('translate-y-0', 'opacity-100', 'pointer-events-auto');
                mobileSearchOverlay.classList.add('-translate-y-full', 'opacity-0', 'pointer-events-none');
            }
        }

        function handleSearchDesktop(page = 1) {
            if (searchInputMobile) searchInputMobile.value = searchInputDesktop.value;
            handleSearch(page);
        }

        function handleSearchMobile(page = 1) {
            if (searchInputDesktop) searchInputDesktop.value = searchInputMobile.value;
            toggleMobileSearchOverlay(false);
            handleSearch(page);
        }
        
        async function handleSearch(page = 1) {
            const query = searchInputDesktop.value.trim();
            
            window.scrollTo(0, 0); 
            
            if (query.length < 2) {
                navigateTo('popular-movies-section', 1); 
                if (query.length !== 0) {
                     showStatus('Please enter at least 2 characters for search.', 'info');
                }
                return;
            }
            
            searchResultsSection.classList.remove('hidden');
            
            await fetchAndRender('search', page, query);
        }

        function navigateTo(sectionId, resetPage = 1) {
            
            [popularMoviesSection, popularTvSection, searchResultsSection].forEach(section => {
                section.classList.add('hidden');
            });
            clearStatus();
            
            if (sectionId !== 'search-results-section') {
                if (searchInputDesktop) searchInputDesktop.value = '';
                if (searchInputMobile) searchInputMobile.value = '';
            }
            
            document.getElementById(sectionId).classList.remove('hidden');
            
            let mediaType;
            if (sectionId === 'popular-movies-section') {
                mediaType = 'movie';
            } else if (sectionId === 'popular-tv-section') {
                mediaType = 'tv';
            } else if (sectionId === 'search-results-section' && currentQuery) {
                mediaType = 'search';
            }
            
            if (mediaType && currentPage[mediaType] !== resetPage) {
                currentPage[mediaType] = resetPage;
            }

            if (mediaType === 'movie' || mediaType === 'tv') {
                 // Re-render filters and sort buttons to ensure active state is correct
                renderFilterButtons(mediaType, 'genre');
                renderFilterButtons(mediaType, 'country');
                
                // Update sort buttons active state
                const filterContainer = document.getElementById(`${mediaType}-sort-filters`);
                if (filterContainer) {
                    filterContainer.querySelectorAll('.sort-button').forEach(button => {
                        if (button.dataset.sort === currentSort[mediaType]) {
                            button.classList.add('active');
                        } else {
                            button.classList.remove('active');
                        }
                    });
                }

                fetchAndRender(mediaType, currentPage[mediaType]);
            } else if (mediaType === 'search') {
                handleSearch(currentPage['search']);
            }

            desktopNavLinks.forEach(link => {
                link.classList.remove('border-accent', 'text-accent');
                link.classList.add('border-transparent');
            });
            const activeDesktopLink = document.querySelector(`#desktop-nav [data-section-id="${sectionId}"]`);
            if (activeDesktopLink) {
                 activeDesktopLink.classList.add('border-accent', 'text-accent');
                 activeDesktopLink.classList.remove('border-transparent');
            }

            mobileNavItems.forEach(item => {
                item.classList.remove('active', 'text-accent');
            });
            const activeMobileItem = document.querySelector(`#mobile-nav-footer [data-section-id="${sectionId}"]`);
            if (activeMobileItem) {
                 activeMobileItem.classList.add('active', 'text-accent');
            }
            
            document.getElementById(sectionId).scrollIntoView({ behavior: 'smooth', block: 'start' });
        }


        /**
         * Initial function to load popular content and render filter UIs on page load.
         */
        async function loadInitialContent() {
            // Render all filter buttons AND dropdowns for both views
            renderFilterButtons('movie', 'genre');
            renderFilterButtons('movie', 'country');
            renderFilterButtons('tv', 'genre');
            renderFilterButtons('tv', 'country');

            // Set loading skeletons for initial default view (Movies)
            popularMoviesContainer.innerHTML = Array(6).fill(createLoadingSkeleton()).join('');
            
            // Set the initial navigation state, which triggers the fetch for the default view (Movies, page 1)
            navigateTo('popular-movies-section', 1);
        }

        // Initialize content when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', loadInitialContent);
    </script>
</body>
</html>
